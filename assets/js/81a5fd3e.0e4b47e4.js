"use strict";(self.webpackChunktypescript_eslint_chinese=self.webpackChunktypescript_eslint_chinese||[]).push([[1519],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(t),m=i,y=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return t?r.createElement(y,a(a({ref:n},c),{},{components:t})):r.createElement(y,a({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=d;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3373:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=t(3117),i=t(102),o=(t(7294),t(3905)),a=["components"],l={},p="sort-type-union-intersection-members",s={unversionedId:"sort-type-union-intersection-members",id:"sort-type-union-intersection-members",title:"sort-type-union-intersection-members",description:"Enforces members of a type union/intersection to be sorted alphabetically.",source:"@site/rules/sort-type-union-intersection-members.md",sourceDirName:".",slug:"/sort-type-union-intersection-members",permalink:"/typescript-eslint-chinese/rules/sort-type-union-intersection-members",draft:!1,tags:[],version:"current",lastUpdatedBy:"GEARLESS JOE",lastUpdatedAt:1657247748,formattedLastUpdatedAt:"2022\u5e747\u67088\u65e5",frontMatter:{},sidebar:"rules",previous:{title:"semi",permalink:"/typescript-eslint-chinese/rules/semi"},next:{title:"space-before-blocks",permalink:"/typescript-eslint-chinese/rules/space-before-blocks"}},c={},u=[{value:"Rule Details",id:"rule-details",level:2},{value:"\u274c Incorrect",id:"-incorrect",level:3},{value:"\u2705 Correct",id:"-correct",level:3},{value:"Options",id:"options",level:2},{value:"<code>groupOrder</code>",id:"grouporder",level:3}],d={toc:u};function m(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"sort-type-union-intersection-members"},(0,o.kt)("inlineCode",{parentName:"h1"},"sort-type-union-intersection-members")),(0,o.kt)("p",null,"Enforces members of a type union/intersection to be sorted alphabetically."),(0,o.kt)("p",null,"Sorting union (",(0,o.kt)("inlineCode",{parentName:"p"},"|"),") and intersection (",(0,o.kt)("inlineCode",{parentName:"p"},"&"),") types can help:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"keep your codebase standardized"),(0,o.kt)("li",{parentName:"ul"},"find repeated types"),(0,o.kt)("li",{parentName:"ul"},"reduce diff churn")),(0,o.kt)("h2",{id:"rule-details"},"Rule Details"),(0,o.kt)("p",null,"Sorting within each group is done using the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const collator = new Intl.Collator("en", {\n  sensitivity: "base",\n  numeric: true,\n});\n\nfunction compare(a, b) {\n  return collator.compare(a, b) || (a < b ? -1 : a > b ? 1 : 0);\n}\n')),(0,o.kt)("p",null,"In other words, the types are sorted alphabetically, case-insensitively and treating numbers like a human would, falling back to character code sorting in case of ties."),(0,o.kt)("p",null,"Examples of code for this rule:"),(0,o.kt)("h3",{id:"-incorrect"},"\u274c Incorrect"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'type T1 = B | A;\n\ntype T2 = { b: string } & { a: string };\n\ntype T3 = [1, 2, 4] & [1, 2, 3];\n\ntype T4 =\n  | [1, 2, 4]\n  | [1, 2, 3]\n  | { b: string }\n  | { a: string }\n  | (() => void)\n  | (() => string)\n  | "b"\n  | "a"\n  | "b"\n  | "a"\n  | readonly string[]\n  | readonly number[]\n  | string[]\n  | number[]\n  | B\n  | A\n  | string\n  | any;\n')),(0,o.kt)("h3",{id:"-correct"},"\u2705 Correct"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'type T1 = A | B;\n\ntype T2 = { a: string } & { b: string };\n\ntype T3 = [1, 2, 3] & [1, 2, 4];\n\ntype T4 =\n  | any\n  | string\n  | A\n  | B\n  | number[]\n  | string[]\n  | readonly number[]\n  | readonly string[]\n  | "a"\n  | "b"\n  | "a"\n  | "b"\n  | (() => string)\n  | (() => void)\n  | { a: string }\n  | { b: string }\n  | [1, 2, 3]\n  | [1, 2, 4];\n')),(0,o.kt)("h2",{id:"options"},"Options"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'type Options = {\n  // true to check intersection types, false otherwise\n  checkIntersections?: boolean;\n  // true to check union types, false otherwise\n  checkUnions?: boolean;\n  // the ordering of the groups\n  groupOrder?: (\n    | "conditional"\n    | "function"\n    | "import"\n    | "intersection"\n    | "keyword"\n    | "literal"\n    | "named"\n    | "object"\n    | "operator"\n    | "tuple"\n    | "union"\n    | "nullish"\n  )[];\n};\n\nconst defaultOptions: Options = {\n  checkIntersections: true,\n  checkUnions: true,\n  groupOrder: [\n    "named",\n    "keyword",\n    "operator",\n    "literal",\n    "function",\n    "import",\n    "conditional",\n    "object",\n    "tuple",\n    "intersection",\n    "union",\n    "nullish",\n  ],\n};\n')),(0,o.kt)("h3",{id:"grouporder"},(0,o.kt)("inlineCode",{parentName:"h3"},"groupOrder")),(0,o.kt)("p",null,"Each member of the type is placed into a group, and then the rule sorts alphabetically within each group.\nThe ordering of groups is determined by this option."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"conditional")," - Conditional types (",(0,o.kt)("inlineCode",{parentName:"li"},"A extends B ? C : D"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"function")," - Function and constructor types (",(0,o.kt)("inlineCode",{parentName:"li"},"() => void"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"new () => type"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"import")," - Import types (",(0,o.kt)("inlineCode",{parentName:"li"},"import('path')"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"intersection")," - Intersection types (",(0,o.kt)("inlineCode",{parentName:"li"},"A & B"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"keyword")," - Keyword types (",(0,o.kt)("inlineCode",{parentName:"li"},"any"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"string"),", etc)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"literal")," - Literal types (",(0,o.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"'b'"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),", etc)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"named")," - Named types (",(0,o.kt)("inlineCode",{parentName:"li"},"A"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"A['prop']"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"B[]"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Array<C>"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"object")," - Object types (",(0,o.kt)("inlineCode",{parentName:"li"},"{ a: string }"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"{ [key: string]: number }"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"operator")," - Operator types (",(0,o.kt)("inlineCode",{parentName:"li"},"keyof A"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"typeof B"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"readonly C[]"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tuple")," - Tuple types (",(0,o.kt)("inlineCode",{parentName:"li"},"[A, B, C]"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"union")," - Union types (",(0,o.kt)("inlineCode",{parentName:"li"},"A | B"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nullish")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"undefined"))))}m.isMDXComponent=!0}}]);