"use strict";(self.webpackChunktypescript_eslint_chinese=self.webpackChunktypescript_eslint_chinese||[]).push([[4996],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),f=o,m=d["".concat(s,".").concat(f)]||d[f]||p[f]||i;return t?r.createElement(m,a(a({ref:n},u),{},{components:t})):r.createElement(m,a({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<i;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8956:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var r=t(3117),o=t(102),i=(t(7294),t(3905)),a=["components"],l={},s="explicit-module-boundary-types",c={unversionedId:"explicit-module-boundary-types",id:"explicit-module-boundary-types",title:"explicit-module-boundary-types",description:"Requires explicit return and argument types on exported functions' and classes' public class methods.",source:"@site/rules/explicit-module-boundary-types.md",sourceDirName:".",slug:"/explicit-module-boundary-types",permalink:"/typescript-eslint-chinese/rules/explicit-module-boundary-types",draft:!1,tags:[],version:"current",lastUpdatedBy:"GEARLESS JOE",lastUpdatedAt:1657247748,formattedLastUpdatedAt:"2022\u5e747\u67088\u65e5",frontMatter:{},sidebar:"rules",previous:{title:"explicit-member-accessibility",permalink:"/typescript-eslint-chinese/rules/explicit-member-accessibility"},next:{title:"func-call-spacing",permalink:"/typescript-eslint-chinese/rules/func-call-spacing"}},u={},p=[{value:"Rule Details",id:"rule-details",level:2},{value:"\u274c Incorrect",id:"-incorrect",level:3},{value:"\u2705 Correct",id:"-correct",level:3},{value:"Options",id:"options",level:2},{value:"Configuring in a mixed JS/TS codebase",id:"configuring-in-a-mixed-jsts-codebase",level:3},{value:"<code>allowArgumentsExplicitlyTypedAsAny</code>",id:"allowargumentsexplicitlytypedasany",level:3},{value:"\u274c Incorrect",id:"-incorrect-1",level:4},{value:"\u2705 Correct",id:"-correct-1",level:4},{value:"<code>allowDirectConstAssertionInArrowFunctions</code>",id:"allowdirectconstassertioninarrowfunctions",level:3},{value:"\u274c Incorrect",id:"-incorrect-2",level:4},{value:"\u2705 Correct",id:"-correct-2",level:4},{value:"<code>allowedNames</code>",id:"allowednames",level:3},{value:"<code>allowHigherOrderFunctions</code>",id:"allowhigherorderfunctions",level:3},{value:"\u274c Incorrect",id:"-incorrect-3",level:4},{value:"\u2705 Correct",id:"-correct-3",level:4},{value:"<code>allowTypedFunctionExpressions</code>",id:"allowtypedfunctionexpressions",level:3},{value:"\u274c Incorrect",id:"-incorrect-4",level:4},{value:"\u2705 Correct",id:"-correct-4",level:4},{value:"When Not To Use It",id:"when-not-to-use-it",level:2},{value:"Further Reading",id:"further-reading",level:2}],d={toc:p};function f(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"explicit-module-boundary-types"},(0,i.kt)("inlineCode",{parentName:"h1"},"explicit-module-boundary-types")),(0,i.kt)("p",null,"Requires explicit return and argument types on exported functions' and classes' public class methods."),(0,i.kt)("p",null,"Explicit types for function return values and arguments makes it clear to any calling code what is the module boundary's input and output."),(0,i.kt)("h2",{id:"rule-details"},"Rule Details"),(0,i.kt)("p",null,"This rule aims to ensure that the values returned from a module are of the expected type."),(0,i.kt)("h3",{id:"-incorrect"},"\u274c Incorrect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Should indicate that no value is returned (void)\nexport function test() {\n  return;\n}\n\n// Should indicate that a number is returned\nexport default function () {\n  return 1;\n}\n\n// Should indicate that a string is returned\nexport var arrowFn = () => "test";\n\n// All arguments should be typed\nexport var arrowFn = (arg): string => `test ${arg}`;\nexport var arrowFn = (arg: any): string => `test ${arg}`;\n\nexport class Test {\n  // Should indicate that no value is returned (void)\n  method() {\n    return;\n  }\n}\n')),(0,i.kt)("h3",{id:"-correct"},"\u2705 Correct"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Function is not exported\nfunction test() {\n  return;\n}\n\n// A return value of type number\nexport var fn = function (): number {\n  return 1;\n};\n\n// A return value of type string\nexport var arrowFn = (arg: string): string => `test ${arg}`;\n\n// All arguments should be typed\nexport var arrowFn = (arg: string): string => `test ${arg}`;\nexport var arrowFn = (arg: unknown): string => `test ${arg}`;\n\n// Class is not exported\nclass Test {\n  method() {\n    return;\n  }\n}\n")),(0,i.kt)("h2",{id:"options"},"Options"),(0,i.kt)("p",null,"The rule accepts an options object with the following properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type Options = {\n  /**\n   * If true, the rule will not report for arguments that are explicitly typed as `any`\n   */\n  allowArgumentsExplicitlyTypedAsAny?: boolean;\n  /**\n   * If true, body-less arrow functions that return an `as const` type assertion will not\n   * require an explicit return value annotation.\n   * You must still type the parameters of the function.\n   */\n  allowDirectConstAssertionInArrowFunctions?: boolean;\n  /**\n   * An array of function/method names that will not have their arguments or their return values checked.\n   */\n  allowedNames?: string[];\n  /**\n   * If true, functions immediately returning another function expression will not\n   * require an explicit return value annotation.\n   * You must still type the parameters of the function.\n   */\n  allowHigherOrderFunctions?: boolean;\n  /**\n   * If true, type annotations are also allowed on the variable of a function expression\n   * rather than on the function arguments/return value directly.\n   */\n  allowTypedFunctionExpressions?: boolean;\n};\n\nconst defaults = {\n  allowArgumentsExplicitlyTypedAsAny: false,\n  allowDirectConstAssertionInArrowFunctions: true,\n  allowedNames: [],\n  allowHigherOrderFunctions: true,\n  allowTypedFunctionExpressions: true,\n};\n")),(0,i.kt)("h3",{id:"configuring-in-a-mixed-jsts-codebase"},"Configuring in a mixed JS/TS codebase"),(0,i.kt)("p",null,"If you are working on a codebase within which you lint non-TypeScript code (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},".js"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".mjs"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".cjs"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".jsx"),"), you should ensure that you should use ",(0,i.kt)("a",{parentName:"p",href:"https://eslint.org/docs/user-guide/configuring#disabling-rules-only-for-a-group-of-files"},"ESLint ",(0,i.kt)("inlineCode",{parentName:"a"},"overrides"))," to only enable the rule on ",(0,i.kt)("inlineCode",{parentName:"p"},".ts"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".mts"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".cts"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".tsx")," files. If you don't, then you will get unfixable lint errors reported within ",(0,i.kt)("inlineCode",{parentName:"p"},".js"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".mjs"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".cjs"),"/",(0,i.kt)("inlineCode",{parentName:"p"},".jsx")," files."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsonc"},'{\n  "rules": {\n    // disable the rule for all files\n    "@typescript-eslint/explicit-module-boundary-types": "off"\n  },\n  "overrides": [\n    {\n      // enable the rule specifically for TypeScript files\n      "files": ["*.ts", "*.mts", "*.cts", "*.tsx"],\n      "rules": {\n        "@typescript-eslint/explicit-module-boundary-types": ["error"]\n      }\n    }\n  ]\n}\n')),(0,i.kt)("h3",{id:"allowargumentsexplicitlytypedasany"},(0,i.kt)("inlineCode",{parentName:"h3"},"allowArgumentsExplicitlyTypedAsAny")),(0,i.kt)("p",null,"Examples of code for this rule with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ allowArgumentsExplicitlyTypedAsAny: false }"),":"),(0,i.kt)("h4",{id:"-incorrect-1"},"\u274c Incorrect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export const func = (value: any): number => value + 1;\n")),(0,i.kt)("h4",{id:"-correct-1"},"\u2705 Correct"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export const func = (value: number): number => value + 1;\n")),(0,i.kt)("h3",{id:"allowdirectconstassertioninarrowfunctions"},(0,i.kt)("inlineCode",{parentName:"h3"},"allowDirectConstAssertionInArrowFunctions")),(0,i.kt)("p",null,"Examples of code for this rule with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ allowDirectConstAssertionInArrowFunctions: false }"),":"),(0,i.kt)("h4",{id:"-incorrect-2"},"\u274c Incorrect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export const func = (value: number) => ({ type: "X", value });\nexport const foo = () => ({\n  bar: true,\n});\nexport const bar = () => 1;\n')),(0,i.kt)("h4",{id:"-correct-2"},"\u2705 Correct"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export const func = (value: number) => ({ type: "X", value } as const);\nexport const foo = () =>\n  ({\n    bar: true,\n  } as const);\nexport const bar = () => 1 as const;\n')),(0,i.kt)("h3",{id:"allowednames"},(0,i.kt)("inlineCode",{parentName:"h3"},"allowedNames")),(0,i.kt)("p",null,"You may pass function/method names you would like this rule to ignore, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@typescript-eslint/explicit-module-boundary-types": [\n    "error",\n    {\n      "allowedNames": ["ignoredFunctionName", "ignoredMethodName"]\n    }\n  ]\n}\n')),(0,i.kt)("h3",{id:"allowhigherorderfunctions"},(0,i.kt)("inlineCode",{parentName:"h3"},"allowHigherOrderFunctions")),(0,i.kt)("p",null,"Examples of code for this rule with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ allowHigherOrderFunctions: false }"),":"),(0,i.kt)("h4",{id:"-incorrect-3"},"\u274c Incorrect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export const arrowFn = () => () => {};\n\nexport function fn() {\n  return function () {};\n}\n\nexport function foo(outer: string) {\n  return function (inner: string) {};\n}\n")),(0,i.kt)("h4",{id:"-correct-3"},"\u2705 Correct"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export const arrowFn = () => (): void => {};\n\nexport function fn() {\n  return function (): void {};\n}\n\nexport function foo(outer: string) {\n  return function (inner: string): void {};\n}\n")),(0,i.kt)("h3",{id:"allowtypedfunctionexpressions"},(0,i.kt)("inlineCode",{parentName:"h3"},"allowTypedFunctionExpressions")),(0,i.kt)("p",null,"Examples of code for this rule with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ allowTypedFunctionExpressions: false }"),":"),(0,i.kt)("h4",{id:"-incorrect-4"},"\u274c Incorrect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export let arrowFn = () => "test";\n\nexport let funcExpr = function () {\n  return "test";\n};\n\nexport let objectProp = {\n  foo: () => 1,\n};\n\nexport const foo = (bar) => {};\n')),(0,i.kt)("h4",{id:"-correct-4"},"\u2705 Correct"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'type FuncType = () => string;\n\nexport let arrowFn: FuncType = () => "test";\n\nexport let funcExpr: FuncType = function () {\n  return "test";\n};\n\nexport let asTyped = (() => "") as () => string;\nexport let castTyped = <() => string>(() => "");\n\ninterface ObjectType {\n  foo(): number;\n}\nexport let objectProp: ObjectType = {\n  foo: () => 1,\n};\nexport let objectPropAs = {\n  foo: () => 1,\n} as ObjectType;\nexport let objectPropCast = <ObjectType>{\n  foo: () => 1,\n};\n\ntype FooType = (bar: string) => void;\nexport const foo: FooType = (bar) => {};\n')),(0,i.kt)("h2",{id:"when-not-to-use-it"},"When Not To Use It"),(0,i.kt)("p",null,"If you wish to make sure all functions have explicit return types, as opposed to only the module boundaries, you can use ",(0,i.kt)("a",{parentName:"p",href:"/typescript-eslint-chinese/rules/explicit-function-return-type"},"explicit-function-return-type")),(0,i.kt)("h2",{id:"further-reading"},"Further Reading"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"TypeScript ",(0,i.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/functions.html#function-types"},"Functions"))))}f.isMDXComponent=!0}}]);