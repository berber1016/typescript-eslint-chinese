"use strict";(self.webpackChunktypescript_eslint_chinese=self.webpackChunktypescript_eslint_chinese||[]).push([[8945],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,y=d["".concat(l,".").concat(m)]||d[m]||c[m]||a;return n?r.createElement(y,o(o({ref:t},u),{},{components:n})):r.createElement(y,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2490:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var r=n(3117),i=n(102),a=(n(7294),n(3905)),o=["components"],s={id:"custom-rules",sidebar_label:"Custom Rules",title:"Custom Rules"},l=void 0,p={unversionedId:"development/custom-rules",id:"development/custom-rules",title:"Custom Rules",description:"You should be familiar with ESLint's developer guide and Development > Architecture before writing custom rules.",source:"@site/docs/development/CUSTOM_RULES.md",sourceDirName:"development",slug:"/development/custom-rules",permalink:"/typescript-eslint-chinese/docs/development/custom-rules",draft:!1,tags:[],version:"current",lastUpdatedBy:"GEARLESS JOE",lastUpdatedAt:1657247748,formattedLastUpdatedAt:"2022\u5e747\u67088\u65e5",frontMatter:{id:"custom-rules",sidebar_label:"Custom Rules",title:"Custom Rules"},sidebar:"docs",previous:{title:"Packages",permalink:"/typescript-eslint-chinese/docs/development/architecture/packages"}},u={},c=[{value:"Utils Package",id:"utils-package",level:2},{value:"<code>RuleCreator</code>",id:"rulecreator",level:3},{value:"Undocumented Rules",id:"undocumented-rules",level:3},{value:"AST Extensions",id:"ast-extensions",level:2},{value:"Node Types",id:"node-types",level:3},{value:"Explicit Node Types",id:"explicit-node-types",level:3},{value:"Type Checking",id:"type-checking",level:2},{value:"Testing",id:"testing",level:2},{value:"Testing Untyped Rules",id:"testing-untyped-rules",level:3},{value:"Testing Typed Rules",id:"testing-typed-rules",level:3}],d={toc:c};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"important"},(0,a.kt)("p",{parentName:"admonition"},"You should be familiar with ",(0,a.kt)("a",{parentName:"p",href:"https://eslint.org/docs/developer-guide"},"ESLint's developer guide")," and ",(0,a.kt)("a",{parentName:"p",href:"./architecture/asts"},"Development > Architecture")," before writing custom rules.")),(0,a.kt)("p",null,"As long as you are using ",(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/parser")," as the ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," in your ESLint configuration, custom ESLint rules generally work the same way for JavaScript and TypeScript code.\nThe main three changes to custom rules writing are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#utils-package"},"Utils Package"),": we recommend using ",(0,a.kt)("inlineCode",{parentName:"li"},"@typescript-eslint/utils")," to create custom rules"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#ast-extensions"},"AST Extensions"),": targeting TypeScript-specific syntax in your rule selectors"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#typed-rules"},"Typed Rules"),": using the TypeScript type checker to inform rule logic")),(0,a.kt)("h2",{id:"utils-package"},"Utils Package"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils")," package acts as a replacement package for ",(0,a.kt)("inlineCode",{parentName:"p"},"eslint")," that exports all the same objects and types, but with typescript-eslint support.\nIt also exports common utility functions and constants most custom typescript-eslint rules tend to use."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"@types/eslint")," types are based on ",(0,a.kt)("inlineCode",{parentName:"p"},"@types/estree")," and do not recognize typescript-eslint nodes and properties.\nYou should generally not need to import from ",(0,a.kt)("inlineCode",{parentName:"p"},"eslint")," when writing custom typescript-eslint rules in TypeScript.")),(0,a.kt)("h3",{id:"rulecreator"},(0,a.kt)("inlineCode",{parentName:"h3"},"RuleCreator")),(0,a.kt)("p",null,"The recommended way to create custom ESLint rules that make use of typescript-eslint features and/or syntax is with the ",(0,a.kt)("inlineCode",{parentName:"p"},"ESLintUtils.RuleCreator")," function exported by ",(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils"),"."),(0,a.kt)("p",null,"It takes in a function that transforms a rule name into its documentation URL, then returns a function that takes in a rule module object.\n",(0,a.kt)("inlineCode",{parentName:"p"},"RuleCreator")," will infer the allowed message IDs the rule is allowed to emit from the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"meta.messages")," object."),(0,a.kt)("p",null,"This rule bans function declarations that start with a lower-case letter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\n\nconst createRule = ESLintUtils.RuleCreator(\n  (name) => `https://example.com/rule/${name}`\n);\n\n// Type: RuleModule<"uppercase", ...>\nexport const rule = createRule({\n  create(context) {\n    return {\n      FunctionDeclaration(node) {\n        if (node.id != null) {\n          if (/^[a-z]/.test(node.id.name)) {\n            context.report({\n              messageId: "uppercase",\n              node: node.id,\n            });\n          }\n        }\n      },\n    };\n  },\n  name: "uppercase-first-declarations",\n  meta: {\n    docs: {\n      description:\n        "Function declaration names should start with an upper-case letter.",\n      recommended: "warn",\n    },\n    messages: {\n      uppercase: "Start this name with an upper-case letter.",\n    },\n    type: "suggestion",\n    schema: [],\n  },\n  defaultOptions: [],\n});\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"RuleCreator")," rule creator functions return rules typed as the ",(0,a.kt)("inlineCode",{parentName:"p"},"RuleModule")," interface exported by ",(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils"),".\nIt allows specifying generics for:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"MessageIds"),": a union of string literal message IDs that may be reported"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Options"),": what options users may configure for the rule (by default, ",(0,a.kt)("inlineCode",{parentName:"li"},"[]"),")")),(0,a.kt)("p",null,"If the rule is able to take in rule options, declare them as a tuple type containing a single object of rule options:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\n\ntype MessageIds = "lowercase" | "uppercase";\n\ntype Options = [\n  {\n    preferredCase?: "lower" | "upper";\n  }\n];\n\n// Type: RuleModule<MessageIds, Options, ...>\nexport const rule = createRule<Options, MessageIds>({\n  // ...\n});\n')),(0,a.kt)("h3",{id:"undocumented-rules"},"Undocumented Rules"),(0,a.kt)("p",null,"Although it is generally not recommended to create custom rules without documentation, if you are sure you want to do this you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"ESLintUtils.RuleCreator.withoutDocs")," function to directly create a rule.\nIt applies the same type inference as the ",(0,a.kt)("inlineCode",{parentName:"p"},"createRule"),"s above without enforcing a documentation URL."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\n\nexport const rule = ESLintUtils.RuleCreator.withoutDocs({\n  create(context) {\n    // ...\n  },\n  meta: {\n    // ...\n  },\n});\n')),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"We recommend any custom ESLint rule include a descriptive error message and link to informative documentation.")),(0,a.kt)("h2",{id:"ast-extensions"},"AST Extensions"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/estree")," creates AST nodes for TypeScript syntax with names that begin with ",(0,a.kt)("inlineCode",{parentName:"p"},"TS"),", such as ",(0,a.kt)("inlineCode",{parentName:"p"},"TSInterfaceDeclaration")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"TSTypeAnnotation"),".\nThese nodes are treated just like any other AST node.\nYou can query for them in your rule selectors."),(0,a.kt)("p",null,"This version of the above rule instead bans interface declaration names that start with a lower-case letter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\n\nexport const rule = createRule({\n  create(context) {\n    return {\n      TSInterfaceDeclaration(node) {\n        if (/^[a-z]/.test(node.id.name)) {\n          // ...\n        }\n      },\n    };\n  },\n  // ...\n});\n')),(0,a.kt)("h3",{id:"node-types"},"Node Types"),(0,a.kt)("p",null,"TypeScript types for nodes exist in a ",(0,a.kt)("inlineCode",{parentName:"p"},"TSESTree")," namespace exported by ",(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils"),".\nThe above rule body could be better written in TypeScript with a type annotation on the ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),":"),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"AST_NODE_TYPES")," enum is exported as well to hold the values for AST node ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," properties.\n",(0,a.kt)("inlineCode",{parentName:"p"},"TSESTree.Node")," is available as union type that uses its ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," member as a discriminant."),(0,a.kt)("p",null,"For example, checking ",(0,a.kt)("inlineCode",{parentName:"p"},"node.type")," can narrow down the type of the ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { AST_NODE_TYPES, TSESTree } from "@typescript-eslint/utils";\n\nexport function describeNode(node: TSESTree.Node): string {\n  switch (node.type) {\n    case AST_NODE_TYPES.ArrayExpression:\n      return `Array containing ${node.elements.map(describeNode).join(", ")}`;\n\n    case AST_NODE_TYPES.Literal:\n      return `Literal value ${node.raw}`;\n\n    default:\n      return "\ud83e\udd37";\n  }\n}\n')),(0,a.kt)("h3",{id:"explicit-node-types"},"Explicit Node Types"),(0,a.kt)("p",null,"Rule queries that use more features of ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/estools/esquery"},"esquery")," such as targeting multiple node types may not be able to infer the type of the ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),".\nIn that case, it is best to add an explicit type declaration."),(0,a.kt)("p",null,"This rule snippet targets name nodes of both function and interface declarations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { AST_NODE_TYPES, ESLintUtils } from "@typescript-eslint/utils";\n\nexport const rule = createRule({\n  create(context) {\n    return {\n      "FunctionDeclaration, TSInterfaceDeclaration"(\n        node:\n          | AST_NODE_TYPES.FunctionDeclaration\n          | AST_NODE_TYPES.TSInterfaceDeclaration\n      ) {\n        if (/^[a-z]/.test(node.id.name)) {\n          // ...\n        }\n      },\n    };\n  },\n  // ...\n});\n')),(0,a.kt)("h2",{id:"type-checking"},"Type Checking"),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Read TypeScript's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API#using-the-type-checker"},"Compiler APIs > Using the Type Checker")," section for how to use a program's type checker.")),(0,a.kt)("p",null,"The biggest addition typescript-eslint brings to ESLint rules is the ability to use TypeScript's type checker APIs."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils")," exports an ",(0,a.kt)("inlineCode",{parentName:"p"},"ESLintUtils")," namespace containing a ",(0,a.kt)("inlineCode",{parentName:"p"},"getParserServices")," function that takes in an ESLint context and returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"parserServices")," object."),(0,a.kt)("p",null,"That ",(0,a.kt)("inlineCode",{parentName:"p"},"parserServices")," object contains:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"program"),": A full TypeScript ",(0,a.kt)("inlineCode",{parentName:"li"},"ts.Program")," object"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"esTreeNodeToTSNodeMap"),": Map of ",(0,a.kt)("inlineCode",{parentName:"li"},"@typescript-eslint/estree")," ",(0,a.kt)("inlineCode",{parentName:"li"},"TSESTree.Node")," nodes to their TypeScript ",(0,a.kt)("inlineCode",{parentName:"li"},"ts.Node")," equivalents"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tsNodeToESTreeNodeMap"),": Map of TypeScript ",(0,a.kt)("inlineCode",{parentName:"li"},"ts.Node")," nodes to their ",(0,a.kt)("inlineCode",{parentName:"li"},"@typescript-eslint/estree")," ",(0,a.kt)("inlineCode",{parentName:"li"},"TSESTree.Node")," equivalents")),(0,a.kt)("p",null,"By mapping from ESTree nodes to TypeScript nodes and retrieving the TypeScript program from the parser services, rules are able to ask TypeScript for full type information on those nodes."),(0,a.kt)("p",null,"This rule bans for-of looping over an enum by using the type-checker via typescript-eslint and TypeScript APIs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\nimport * as ts from "typescript";\nimport * as tsutils from "tsutils";\n\nexport const rule: eslint.Rule.RuleModule = {\n  create(context) {\n    return {\n      ForOfStatement(node) {\n        // 1. Grab the TypeScript program from parser services\n        const parserServices = ESLintUtils.getParserServices(context);\n        const checker = parserServices.program.getTypeChecker();\n\n        // 2. Find the backing TS node for the ES node, then that TS type\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(\n          node.right\n        );\n        const nodeType = checker.getTypeAtLocation(originalNode);\n\n        // 3. Check the TS node type using the TypeScript APIs\n        if (tsutils.isTypeFlagSet(nodeType, ts.TypeFlags.EnumLike)) {\n          context.report({\n            messageId: "loopOverEnum",\n            node: node.right,\n          });\n        }\n      },\n    };\n  },\n  meta: {\n    docs: {\n      category: "Best Practices",\n      description: "Avoid looping over enums.",\n    },\n    messages: {\n      loopOverEnum: "Do not loop over enums.",\n    },\n    type: "suggestion",\n    schema: [],\n  },\n};\n')),(0,a.kt)("h2",{id:"testing"},"Testing"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"@typescript-eslint/utils")," exports a ",(0,a.kt)("inlineCode",{parentName:"p"},"RuleTester")," with a similar API to the built-in ",(0,a.kt)("a",{parentName:"p",href:"https://eslint.org/docs/developer-guide/nodejs-api#ruletester"},"ESLint ",(0,a.kt)("inlineCode",{parentName:"a"},"RuleTester")),".\nIt should be provided with the same ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"parserOptions")," you would use in your ESLint configuration."),(0,a.kt)("h3",{id:"testing-untyped-rules"},"Testing Untyped Rules"),(0,a.kt)("p",null,"For rules that don't need type information, passing just the ",(0,a.kt)("inlineCode",{parentName:"p"},"parser")," will do:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\nimport rule from "./my-rule";\n\nconst ruleTester = new ESLintUtils.RuleTester({\n  parser: "@typescript-eslint/parser",\n});\n\nruleTester.run("my-rule", rule, {\n  valid: [\n    /* ... */\n  ],\n  invalid: [\n    /* ... */\n  ],\n});\n')),(0,a.kt)("h3",{id:"testing-typed-rules"},"Testing Typed Rules"),(0,a.kt)("p",null,"For rules that do need type information, ",(0,a.kt)("inlineCode",{parentName:"p"},"parserOptions")," must be passed in as well.\nTests must have at least an absolute ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfigRootDir")," path provided as well as a relative ",(0,a.kt)("inlineCode",{parentName:"p"},"project")," path from that directory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ESLintUtils } from "@typescript-eslint/utils";\nimport rule from "./my-typed-rule";\n\nconst ruleTester = new ESLintUtils.RuleTester({\n  parser: "@typescript-eslint/parser",\n  parserOptions: {\n    project: "./tsconfig.json",\n    tsconfigRootDir: __dirname,\n  },\n});\n\nruleTester.run("my-typed-rule", rule, {\n  valid: [\n    /* ... */\n  ],\n  invalid: [\n    /* ... */\n  ],\n});\n')),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"For now, ",(0,a.kt)("inlineCode",{parentName:"p"},"ESLintUtils.RuleTester")," requires the following physical files be present on disk for typed rules:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tsconfig.json"),': tsconfig used as the test "project"'),(0,a.kt)("li",{parentName:"ul"},"One of the following two files:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"file.ts"),": blank test file used for normal TS tests"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"file.tsx"),": blank test file used for tests with ",(0,a.kt)("inlineCode",{parentName:"li"},"parserOptions: { ecmaFeatures: { jsx: true } }")))))))}m.isMDXComponent=!0}}]);