"use strict";(self.webpackChunktypescript_eslint_chinese=self.webpackChunktypescript_eslint_chinese||[]).push([[2920],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),p=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(c.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},f=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),f=p(t),d=r,h=f["".concat(c,".").concat(d)]||f[d]||s[d]||a;return t?o.createElement(h,i(i({ref:n},u),{},{components:t})):o.createElement(h,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=f;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<a;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}f.displayName="MDXCreateElement"},1139:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return s}});var o=t(3117),r=t(102),a=(t(7294),t(3905)),i=["components"],l={},c="prefer-optional-chain",p={unversionedId:"prefer-optional-chain",id:"prefer-optional-chain",title:"prefer-optional-chain",description:"Enforces using concise optional chain expressions instead of chained logical ands.",source:"@site/rules/prefer-optional-chain.md",sourceDirName:".",slug:"/prefer-optional-chain",permalink:"/typescript-eslint-chinese/rules/prefer-optional-chain",draft:!1,tags:[],version:"current",lastUpdatedBy:"GEARLESS JOE",lastUpdatedAt:1657247748,formattedLastUpdatedAt:"2022\u5e747\u67088\u65e5",frontMatter:{},sidebar:"rules",previous:{title:"prefer-nullish-coalescing",permalink:"/typescript-eslint-chinese/rules/prefer-nullish-coalescing"},next:{title:"prefer-readonly-parameter-types",permalink:"/typescript-eslint-chinese/rules/prefer-readonly-parameter-types"}},u={},s=[{value:"Rule Details",id:"rule-details",level:2},{value:"\u274c Incorrect",id:"-incorrect",level:3},{value:"\u2705 Correct",id:"-correct",level:3},{value:"Options",id:"options",level:2},{value:"When Not To Use It",id:"when-not-to-use-it",level:2},{value:"Further Reading",id:"further-reading",level:2}],f={toc:s};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"prefer-optional-chain"},(0,a.kt)("inlineCode",{parentName:"h1"},"prefer-optional-chain")),(0,a.kt)("p",null,"Enforces using concise optional chain expressions instead of chained logical ands."),(0,a.kt)("p",null,"TypeScript 3.7 added support for the optional chain operator.\nThis operator allows you to safely access properties and methods on objects when they are potentially ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'type T = {\n  a?: {\n    b?: {\n      c: string;\n      method?: () => void;\n    };\n  };\n};\n\nfunction myFunc(foo: T | null) {\n  return foo?.a?.b?.c;\n}\n// is roughly equivalent to\nfunction myFunc(foo: T | null) {\n  return foo && foo.a && foo.a.b && foo.a.b.c;\n}\n// or\nfunction myFunc(foo: T | null) {\n  return (((foo || {}).a || {}).b || {}).c;\n}\n\nfunction myFunc(foo: T | null) {\n  return foo?.["a"]?.b?.c;\n}\n// is roughly equivalent to\nfunction myFunc(foo: T | null) {\n  return foo && foo["a"] && foo["a"].b && foo["a"].b.c;\n}\n\nfunction myFunc(foo: T | null) {\n  return foo?.a?.b?.method?.();\n}\n// is roughly equivalent to\nfunction myFunc(foo: T | null) {\n  return foo && foo.a && foo.a.b && foo.a.b.method && foo.a.b.method();\n}\n')),(0,a.kt)("p",null,"Because the optional chain operator ",(0,a.kt)("em",{parentName:"p"},"only")," chains when the property value is ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),", it is much safer than relying upon logical AND operator chaining ",(0,a.kt)("inlineCode",{parentName:"p"},"&&"),"; which chains on any ",(0,a.kt)("em",{parentName:"p"},"truthy")," value."),(0,a.kt)("h2",{id:"rule-details"},"Rule Details"),(0,a.kt)("p",null,"This rule aims enforce the usage of the safer operator."),(0,a.kt)("p",null,"Examples of code for this rule:"),(0,a.kt)("h3",{id:"-incorrect"},"\u274c Incorrect"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"foo && foo.a && foo.a.b && foo.a.b.c;\nfoo && foo['a'] && foo['a'].b && foo['a'].b.c;\nfoo && foo.a && foo.a.b && foo.a.b.method && foo.a.b.method();\n\n(((foo || {}).a || {}).b {}).c;\n(((foo || {})['a'] || {}).b {}).c;\n\n// this rule also supports converting chained strict nullish checks:\nfoo &&\n  foo.a != null &&\n  foo.a.b !== null &&\n  foo.a.b.c != undefined &&\n  foo.a.b.c.d !== undefined &&\n  foo.a.b.c.d.e;\n")),(0,a.kt)("h3",{id:"-correct"},"\u2705 Correct"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'foo?.a?.b?.c;\nfoo?.["a"]?.b?.c;\nfoo?.a?.b?.method?.();\n\nfoo?.a?.b?.c?.d?.e;\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:")," there are a few edge cases where this rule will false positive. Use your best judgement when evaluating reported errors."),(0,a.kt)("h2",{id:"options"},"Options"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsonc"},'// .eslintrc.json\n{\n  "rules": {\n    "@typescript-eslint/prefer-optional-chain": "warn"\n  }\n}\n')),(0,a.kt)("p",null,"This rule is not configurable."),(0,a.kt)("h2",{id:"when-not-to-use-it"},"When Not To Use It"),(0,a.kt)("p",null,"If you are not using TypeScript 3.7 (or greater), then you will not be able to use this rule, as the operator is not supported."),(0,a.kt)("h2",{id:"further-reading"},"Further Reading"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html"},"TypeScript 3.7 Release Notes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/tc39/proposal-optional-chaining/"},"Optional Chaining Proposal"))))}d.isMDXComponent=!0}}]);