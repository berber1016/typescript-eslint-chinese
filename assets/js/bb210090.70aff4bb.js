"use strict";(self.webpackChunktypescript_eslint_chinese=self.webpackChunktypescript_eslint_chinese||[]).push([[5137],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return k}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,p=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=s(t),k=o,d=c["".concat(p,".").concat(k)]||c[k]||m[k]||l;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function k(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,i=new Array(l);i[0]=c;var r={};for(var p in n)hasOwnProperty.call(n,p)&&(r[p]=n[p]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var s=2;s<l;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2460:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return p},default:function(){return k},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return m}});var a=t(3117),o=t(102),l=(t(7294),t(3905)),i=["components"],r={},p="no-type-alias",s={unversionedId:"no-type-alias",id:"no-type-alias",title:"no-type-alias",description:"Disallows type aliases.",source:"@site/rules/no-type-alias.md",sourceDirName:".",slug:"/no-type-alias",permalink:"/typescript-eslint-chinese/rules/no-type-alias",draft:!1,tags:[],version:"current",lastUpdatedBy:"GEARLESS JOE",lastUpdatedAt:1657247748,formattedLastUpdatedAt:"2022\u5e747\u67088\u65e5",frontMatter:{},sidebar:"rules",previous:{title:"no-throw-literal",permalink:"/typescript-eslint-chinese/rules/no-throw-literal"},next:{title:"no-unnecessary-boolean-literal-compare",permalink:"/typescript-eslint-chinese/rules/no-unnecessary-boolean-literal-compare"}},u={},m=[{value:"Rule Details",id:"rule-details",level:2},{value:"Options",id:"options",level:2},{value:"<code>allowAliases</code>",id:"allowaliases",level:3},{value:"<code>allowCallbacks</code>",id:"allowcallbacks",level:3},{value:"<code>allowConditionalTypes</code>",id:"allowconditionaltypes",level:3},{value:"<code>allowConstructors</code>",id:"allowconstructors",level:3},{value:"<code>allowLiterals</code>",id:"allowliterals",level:3},{value:"<code>allowMappedTypes</code>",id:"allowmappedtypes",level:3},{value:"<code>allowTupleTypes</code>",id:"allowtupletypes",level:3},{value:"<code>allowGenerics</code>",id:"allowgenerics",level:3},{value:"When Not To Use It",id:"when-not-to-use-it",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Related To",id:"related-to",level:2}],c={toc:m};function k(e){var n=e.components,t=(0,o.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"no-type-alias"},(0,l.kt)("inlineCode",{parentName:"h1"},"no-type-alias")),(0,l.kt)("p",null,"Disallows type aliases."),(0,l.kt)("p",null,"In TypeScript, type aliases serve three purposes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Aliasing other types so that we can refer to them using a simpler name.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// this...\ntype Person = {\n    firstName: string,\n    lastName: string,\n    age: number\n};\n\nfunction addPerson(person : Person) { ... }\n\n// is easier to read than this...\nfunction addPerson(person : { firstName: string, lastName: string, age: number}) { ... }\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Act sort of like an interface, providing a set of methods and properties that must exist\nin the objects implementing the type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Person = {\n    firstName: string,\n    lastName: string,\n    age: number,\n    walk: () => void,\n    talk: () => void\n};\n\n// you know person will have 3 properties and 2 methods,\n// because the structure has already been defined.\nvar person : Person = { ... }\n\n// so we can be sure that this will work\nperson.walk();\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Act like mapping tools between types to allow quick modifications.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'type Immutable<T> = { readonly [P in keyof T]: T[P] };\n\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype ImmutablePerson = Immutable<Person>;\n\nvar person: ImmutablePerson = { name: "John", age: 30 };\nperson.name = "Brad"; // error, readonly property\n')),(0,l.kt)("p",null,"When aliasing, the type alias does not create a new type, it just creates a new name\nto refer to the original type. So aliasing primitives and other simple types, tuples, unions\nor intersections can some times be redundant."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// this doesn't make much sense\ntype myString = string;\n")),(0,l.kt)("p",null,"On the other hand, using a type alias as an interface can limit your ability to:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Reuse your code: interfaces can be extended or implemented by other types. Type aliases cannot."),(0,l.kt)("li",{parentName:"ul"},"Debug your code: interfaces create a new name, so is easy to identify the base type of an object\nwhile debugging the application.")),(0,l.kt)("p",null,"Finally, mapping types is an advanced technique and leaving it open can quickly become a pain point\nin your application."),(0,l.kt)("h2",{id:"rule-details"},"Rule Details"),(0,l.kt)("p",null,"This rule disallows the use of type aliases in favor of interfaces\nand simplified types (primitives, tuples, unions, intersections, etc)."),(0,l.kt)("h2",{id:"options"},"Options"),(0,l.kt)("p",null,"This rule, in its default state, does not require any argument. If you would like to enable one\nor more of the following you may pass an object with the options set as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowAliases")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to do aliasing (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowCallbacks")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with callbacks (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowConditionalTypes")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with conditional types (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowConstructors")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with constructors (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowLiterals")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with literal objects (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowMappedTypes")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases as mapping tools (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowTupleTypes")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with tuples (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allowGenerics")," set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," will allow you to use type aliases with generics (Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"'),")")),(0,l.kt)("h3",{id:"allowaliases"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowAliases")),(0,l.kt)("p",null,"This applies to primitive types and reference types."),(0,l.kt)("p",null,"The setting accepts the following values:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions"'),", allows aliasing in union statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string | string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-intersections"'),", allows aliasing in intersection statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string & string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions-and-intersections"'),", allows aliasing in union and/or intersection statements.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "always" }')," options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a";\n\ntype Foo = "a" | "b";\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n')),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a";\n\ntype Foo = string;\n\ntype Foo = string & string[];\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar & Baz;\n')),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a" | "b";\n\ntype Foo = string | string[];\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n')),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a";\n\ntype Foo = "a" | "b";\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n')),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// primitives\ntype Foo = string & string[];\n\ntype Foo = `a-${number}` & `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar & Baz;\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a";\n\ntype Foo = string;\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n')),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowAliases": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'// primitives\ntype Foo = "a" | "b";\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\ntype Foo = `a-${number}` & `b-${number}`;\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n')),(0,l.kt)("h3",{id:"allowcallbacks"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowCallbacks")),(0,l.kt)("p",null,"This applies to function types."),(0,l.kt)("p",null,"The setting accepts the following values:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowCallbacks": "always" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = () => void;\n\ntype Foo = (name: string) => string;\n\nclass Person {}\n\ntype Foo = (name: string, age: number) => string | Person;\n\ntype Foo = (name: string, age: number) => string & Person;\n")),(0,l.kt)("h3",{id:"allowconditionaltypes"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowConditionalTypes")),(0,l.kt)("p",null,"This applies to conditional types."),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowConditionalTypes": "always" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T> = T extends number ? number : null;\n")),(0,l.kt)("h3",{id:"allowconstructors"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowConstructors")),(0,l.kt)("p",null,"This applies to constructor types."),(0,l.kt)("p",null,"The setting accepts the following values:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowConstructors": "always" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = new () => void;\n")),(0,l.kt)("h3",{id:"allowliterals"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowLiterals")),(0,l.kt)("p",null,"This applies to literal types (",(0,l.kt)("inlineCode",{parentName:"p"},"type Foo = { ... }"),")."),(0,l.kt)("p",null,"The setting accepts the following options:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions"'),", allows literals in union statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string | string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-intersections"'),", allows literals in intersection statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string & string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions-and-intersections"'),", allows literals in union and/or intersection statements.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "always" }')," options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } & { age: number };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = { name: string } | { age: number };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = { name: string } & { age: number };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n")),(0,l.kt)("h3",{id:"allowmappedtypes"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowMappedTypes")),(0,l.kt)("p",null,"This applies to literal types."),(0,l.kt)("p",null,"The setting accepts the following values:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions"'),", allows aliasing in union statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string | string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-intersections"'),", allows aliasing in intersection statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = string & string[];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions-and-intersections"'),", allows aliasing in union and/or intersection statements.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "always" }')," options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowMappedTypes": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n")),(0,l.kt)("h3",{id:"allowtupletypes"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowTupleTypes")),(0,l.kt)("p",null,"This applies to tuple types (",(0,l.kt)("inlineCode",{parentName:"p"},"type Foo = [number]"),")."),(0,l.kt)("p",null,"The setting accepts the following options:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions"'),", allows tuples in union statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = [string] | [string, string];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-intersections"'),", allows tuples in intersection statements, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"type Foo = [string] & [string, string];")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"in-unions-and-intersections"'),", allows tuples in union and/or intersection statements.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "always" }')," options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [number] | ([number, number] & [string, string]);\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "in-unions" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "in-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"incorrect")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowTupleTypes": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number];\n\ntype Foo = [string];\n")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowLiterals": "in-unions-and-intersections" }')," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"type Foo = [number] & [number, number];\n\ntype Foo = [string] | [number];\n")),(0,l.kt)("h3",{id:"allowgenerics"},(0,l.kt)("inlineCode",{parentName:"h3"},"allowGenerics")),(0,l.kt)("p",null,"This applies to generic types, including TypeScript provided global utility types (",(0,l.kt)("inlineCode",{parentName:"p"},"type Foo = Record<string, number>"),")."),(0,l.kt)("p",null,"The setting accepts the following options:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"always"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"never"')," to active or deactivate the feature.")),(0,l.kt)("p",null,"Examples of ",(0,l.kt)("strong",{parentName:"p"},"correct")," code for the ",(0,l.kt)("inlineCode",{parentName:"p"},'{ "allowGenerics": "always" }')," options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'type Foo = Bar<string>;\n\ntype Foo = Record<string, number>;\n\ntype Foo = Readonly<Bar>;\n\ntype Foo = Partial<Bar>;\n\ntype Foo = Omit<Bar, "a" | "b">;\n')),(0,l.kt)("h2",{id:"when-not-to-use-it"},"When Not To Use It"),(0,l.kt)("p",null,"When you can't express some shape with an interface or you need to use a union, tuple type,\ncallback, etc. that would cause the code to be unreadable or impractical."),(0,l.kt)("h2",{id:"further-reading"},"Further Reading"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html"},"Advanced Types"))),(0,l.kt)("h2",{id:"related-to"},"Related To"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"TSLint: ",(0,l.kt)("a",{parentName:"li",href:"https://palantir.github.io/tslint/rules/interface-over-type-literal/"},"interface-over-type-literal"))))}k.isMDXComponent=!0}}]);